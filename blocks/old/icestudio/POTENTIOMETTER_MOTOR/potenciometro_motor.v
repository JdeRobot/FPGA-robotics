// Code generated by Icestudio 0.3.2-beta
// Sun, 13 May 2018 17:40:04 GMT

`default_nettype none

module main #(
 parameter v922fd0 = 8'd200,
 parameter v37b6ac = 7'b1001000,
 parameter v9d6b53 = 8'b00000010,
 parameter v6e2020 = 8'b00000011,
 parameter v4c597e = 1'b1
) (
 input v852d12,
 input v90f4f5,
 input vclk,
 output [7:0] v5c4753,
 output veaa941,
 output v3137c6,
 output v92f1a3,
 output v113674,
 output v0ebe78,
 output vc15c0a,
 output vb1330a,
 output v022a81,
 output v6eb903,
 output vbf81a5
);
 localparam p0 = v37b6ac;
 localparam p1 = v9d6b53;
 localparam p2 = v6e2020;
 localparam p3 = v4c597e;
 localparam p14 = v922fd0;
 wire w4;
 wire w5;
 wire w6;
 wire [0:7] w7;
 wire w8;
 wire w9;
 wire w10;
 wire w11;
 wire w12;
 wire w13;
 wire w15;
 wire w16;
 wire w17;
 wire w18;
 wire w19;
 wire w20;
 wire [0:7] w21;
 wire w22;
 wire [0:7] w23;
 wire w24;
 wire w25;
 assign veaa941 = w4;
 assign w5 = v90f4f5;
 assign v3137c6 = w6;
 assign v6eb903 = w9;
 assign w10 = v852d12;
 assign w12 = v852d12;
 assign v92f1a3 = w15;
 assign v113674 = w16;
 assign v0ebe78 = w17;
 assign vc15c0a = w18;
 assign vb1330a = w19;
 assign v022a81 = w20;
 assign vbf81a5 = w22;
 assign v5c4753 = w23;
 assign w24 = vclk;
 assign w25 = vclk;
 assign w12 = w10;
 assign w22 = w8;
 assign w23 = w21;
 assign w25 = w24;
 vd740bf #(
  .v44b034(p0),
  .ve6acd8(p1),
  .vac2b99(p2),
  .vf9d73b(p3)
 ) v3d7d9a (
  .v050c0e(w4),
  .vc171c6(w5),
  .v19b093(w6),
  .v9cf3fe(w7),
  .v61b24a(w8),
  .v2296f6(w13),
  .vbe34e6(w24)
 );
 v1374eb vee5024 (
  .vb35196(w10),
  .vfe7756(w13)
 );
 v51874b ve08009 (
  .vd78cf1(w9),
  .v568692(w11),
  .v1bc444(w21),
  .v4f674c(w25)
 );
 v3e6c24 v20acd8 (
  .v608bd9(w11)
 );
 vade377 v517470 (
  .v3f8fed(w12),
  .v8ba3c1(w15),
  .vc83139(w16),
  .v11608b(w17),
  .v1b05bb(w18),
  .v19aebb(w19),
  .vd73ec1(w20)
 );
 main_v84997f v84997f (
  .data(w7),
  .ready(w8),
  .velocity(w21)
 );
 main_vd108d8 #(
  .aux(p14)
 ) vd108d8 (
 
 );
endmodule

module vd740bf #(
 parameter v44b034 = 7'b0000000,
 parameter ve6acd8 =  8'b00000000,
 parameter vac2b99 = 8'b00000000,
 parameter vf9d73b = 1'b0
) (
 input vbe34e6,
 input v2296f6,
 input vc171c6,
 output v050c0e,
 output [7:0] v9cf3fe,
 output v61b24a,
 output v19b093
);
 localparam p7 = v44b034;
 localparam p11 = vf9d73b;
 localparam p12 = ve6acd8;
 localparam p13 = vac2b99;
 wire w0;
 wire [0:7] w1;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 wire w6;
 wire w8;
 wire w9;
 wire w10;
 assign w0 = vbe34e6;
 assign v9cf3fe = w1;
 assign v050c0e = w2;
 assign v19b093 = w4;
 assign w6 = vc171c6;
 assign v61b24a = w8;
 assign w10 = v2296f6;
 assign w4 = w3;
 v9b4ecc v40f3c6 (
  .v790e82(w3),
  .v248807(w5),
  .v6b2a2c(w6),
  .vba979e(w9)
 );
 vd740bf_v4866fc #(
  .direction_slave(p7),
  .readings(p11),
  .registrer2read1(p12),
  .registrer2read2(p13)
 ) v4866fc (
  .clock(w0),
  .data(w1),
  .scl_out(w2),
  .sda_in(w3),
  .sda_enable(w5),
  .ready(w8),
  .sda_out(w9),
  .start(w10)
 );
endmodule

module vd740bf_v4866fc #(
 parameter direction_slave = 0,
 parameter registrer2read1 = 0,
 parameter registrer2read2 = 0,
 parameter readings = 0
) (
 input clock,
 input start,
 input sda_in,
 output scl_out,
 output sda_out,
 output [7:0] data,
 output sda_enable,
 output ready
);
   reg [4:0] count = 0;
   reg [2:0] pos = 3'd7;
   reg finish = 0;
   reg sda = 1'b1;
   reg scl = 1'b1;
   reg round = 1'b1;
   reg enable = 1'b0;
   reg ready_reg = 1'b0;
   reg [3:0] sda_data = 0;
   reg [2:0] count_data = 0;
   reg [7:0] direction;
   reg [7:0] data_reg = 8'b00000000;
 
   //Arduino uses A8: 10101000
   //(28h) 00101000
   //(29h) 00101001
   //20h 00100000 para ver si hemos escrito bien el modo normal
   //identification: 0F  00001111
   //OutTemp: 26h 00100110
   //Status: 27h 00100111
 
   localparam SDA_START   = 5'd0;
   localparam SCL_START   = 5'd1;
   localparam SCL_LOW_prev  = 5'd2;
   localparam SCL_LOW  = 5'd3;
   localparam SCL_HIGH       =5'd4;
   localparam ACK_CLOCK_LOW      = 5'd5;
   localparam ACK_CLOCK_HIGH_prev = 5'd6;
   localparam ACK_CLOCK_HIGH  = 5'd7;
   localparam DATA_WRITE = 5'd8;
   localparam SDA_STOP = 5'd9;
   localparam SCL_STOP = 5'd10;
   localparam DATA_FINAL_LOW = 5'd11;
   localparam DATA_FINAL_HIGH = 5'd12;
   localparam NMAK_LOW = 5'd13;
   localparam NMAK_HIGH = 5'd14;
   localparam CONTROL_TRANSACTION= 5'd15;
   localparam AUX= 5'd16;
 
 
   reg [4:0] state = CONTROL_TRANSACTION;
   reg [2:0] control_states=3'd0;
 
   always @(posedge clock)
       begin
           case(state)
 
           SDA_START:
           begin
             if(start==1'b1) 
             begin
               enable <=1'b1;
               scl<=1'b1;
               sda<=1'b1;
               if(count==5'd19)
               begin
                 count<= 5'd0;
                 sda<=1'b0;
                 state<=SCL_START;
               end
               else begin
                 count<=count+5'd1;
                 state<=SDA_START;
               end 
             end
             else begin
               scl<=1'bz;
               sda<=1'bz;
               enable <= 1'b0;
             end
           end
 
 
           SCL_START: 
           begin
             scl<=1'b1;
             sda<=1'b0;
             if (count == 5'd19)
             begin
               count <= 5'd0;
               scl<=1'b0;
               state<=SCL_LOW_prev;
             end
             else begin
               count <= count + 5'd1;
               state <= SCL_START;
             end
           end
 
 
           SCL_LOW_prev:
           begin
             scl<=0;
             if(count == 5'd9)
             begin
               count <= 5'd0;
               state<=SCL_LOW;
               sda <= direction[pos]; 
               pos <= pos - 3'd1;
             end
             else begin
               count <= count + 5'd1;
               state <= SCL_LOW_prev;
             end
           end
           
           
           SCL_LOW:
           begin
             scl<=1'b0; 
             if(count == 5'd9)
             begin
               count <= 5'd0;
               state<=SCL_HIGH;
             end
             else begin
               count <= count + 5'd1;
               state<=SCL_LOW; 
             end
           end
           
           
           SCL_HIGH: 
           begin
             scl<=1'b1; 
             if(count == 5'd19)
             begin
               count <= 5'd0;
               if (pos == 3'd7)
                 state<=ACK_CLOCK_LOW;
               else
                 state<=SCL_LOW_prev;  
             end
             else begin
               count <= count + 5'd1;
               state<=SCL_HIGH;
             end
           end
 
 
           ACK_CLOCK_LOW:
           begin
             enable<=1'b0;
             scl<=1'b0;
             if(count==5'd19)
             begin
               count <= 5'd0;
               state<=ACK_CLOCK_HIGH_prev;
             end
             else begin
               count <= count + 5'd1;
               state<=ACK_CLOCK_LOW;
             end
           end
 
 
           ACK_CLOCK_HIGH_prev:
           begin
             sda<=1'b1;
             scl<=1'b1;
             if(count==5'd9)
             begin
               count <= 5'd0;
               state<= ACK_CLOCK_HIGH;
               //aqui metemos que pasa si el sda = 1, ppor eso es necesario este estado
             end
             else begin
               count <= count + 5'd1;
               state<=ACK_CLOCK_HIGH_prev;
             end
           end 
           
           
           ACK_CLOCK_HIGH:
           begin
             sda<=1'b1;
             scl<=1'b1;
             if(count==5'd9)
             begin
               count <= 5'd0;
               state <= CONTROL_TRANSACTION;
               scl<=1'b0;
             end
             else begin
               count <= count + 5'd1;
               state<=ACK_CLOCK_HIGH;
             end
           end   
  
 //****************************************************************************************************************
           CONTROL_TRANSACTION:
           begin
             enable<=1'b1;
             if(count==5'd19)
             begin
               case(control_states)
               3'd0:
               begin
                 state<=SDA_START;
                 direction <= {direction_slave, 1'b0};
                 control_states <= 3'd1;  
               end
               3'd1:
               begin
                 state<=SCL_LOW_prev; 
                 direction <= (round == 1'b1) ? registrer2read1:registrer2read2;
                 control_states <= 3'd2;  
               end
               3'd2:
               begin
                 state <= SCL_STOP;
                 round <= !round;
                 direction<={direction_slave, 1'b1};
                 control_states <= 3'd3;  
               end
               3'd3:
               begin
                 state <= DATA_FINAL_LOW;
                 control_states <= 3'd4;  
               end
               3'd4:
               begin
                 state <= SCL_STOP;
                 control_states <= 3'd0;  
               end
               endcase
               count <= 5'd0;
             end
             else begin
               state<=CONTROL_TRANSACTION;
               count <= count+5'd1;
             end
           end
 //***************************************************************************************************************
           SCL_STOP: 
           begin
             sda<=1'b0;
             scl<=1'b0;
             if (count == 5'd19)
             begin
               scl<=1'b1;
               sda<=1'b0;
               count <= 5'd0;
               state<=SDA_STOP;
             end
             else begin
               count <= count + 5'd1;
               state<=SCL_STOP;
             end
           end
           
           
           SDA_STOP:
           begin
             scl<=1'b1;
             sda<=1'b0;
             if (count == 5'd19)
             begin
               sda<=1'b1;
               count<=5'd0;
               if(finish)  
               begin
                 state<= (readings == 1'b1) ? CONTROL_TRANSACTION : AUX;  //sera aux si queremos que pare de leer, sobre todo para debug PROBLEMA, SI LO MANDO A CONTROL TRANSACTION, SCL SE PONE A CERO
                 scl<=1'b1;
               end
               else begin 
                 state<=SDA_START;
               end
               finish <= 1'b0;
             end
             else begin
               state<=SDA_STOP;
               count <= count + 5'd1;
             end
           end
 //******************************************************************************************************************
 
           DATA_FINAL_LOW:
           begin
           finish <= 1'b1;
           enable<=0;
           scl<=1'b0;
           sda<=1'b1;
           if(count == 5'd19)
           begin
             state<=DATA_FINAL_HIGH;
             count<=5'd0;
             sda_data<=sda_data + 3'd1;
           end
           else begin
             state<=DATA_FINAL_LOW;
             count<= count + 5'd1;
           end
 
             
           end
           DATA_FINAL_HIGH:
           begin
           scl<=1'b1;
           sda<=1'b1;
           if(count == 5'd19)
           begin
             count<=5'd0;
             data_reg[count_data]<=sda_in;
             count_data<=count_data+3'd1;
             if(sda_data==4'd8)
             begin
               ready_reg <=1'b1;
               state<=NMAK_LOW; 
               sda_data<=4'd0; 
             end
             else begin
               state<=DATA_FINAL_LOW;
             end
             end
             else begin
               state<=DATA_FINAL_HIGH;
               count<= count + 5'd1;
           end
           end
 
          
           NMAK_LOW:
           begin
           enable<=1'b1;
           scl<=1'b0;
           sda<=1'b1;
           if(count == 5'd19)
           begin
             state<=NMAK_HIGH;
             count<=5'd0;
           end
           else begin
             state<=NMAK_LOW;
             count<= count + 5'd1;
           end
           end
           
           
           NMAK_HIGH:
           begin
           scl<=1'b1;
           sda<=1'b1;
           if(count == 5'd19)
            begin
             state<=CONTROL_TRANSACTION;
             count<=5'd0;
             scl<=1'b0;//ayer
             ready_reg<=1'b0;
           end
           else begin
             state<=NMAK_HIGH;
             count<= count + 5'd1;
           end
           end
 
           AUX:
           begin
             state <= AUX;
           end
 
           endcase
       end
       assign sda_out = sda;
       assign scl_out = scl;
       assign sda_enable =enable;
       assign data = data_reg;
       assign ready = ready_reg;
endmodule

module v9b4ecc (
 input v6b2a2c,
 input v248807,
 input vba979e,
 output v790e82
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 assign w0 = v6b2a2c;
 assign w1 = v248807;
 assign w2 = vba979e;
 assign v790e82 = w3;
 v9b4ecc_v43ad2d v43ad2d (
  .pin(w0),
  .oe(w1),
  .din(w2),
  .dout(w3)
 );
endmodule

module v9b4ecc_v43ad2d (
 input pin,
 input oe,
 input din,
 output dout
);
   SB_IO #(
       .PIN_TYPE(6'b1010_01),
       .PULLUP(1'b0)
   ) triState (
       .PACKAGE_PIN(pin),
       .OUTPUT_ENABLE(oe),
       .D_OUT_0(din),
       .D_IN_0(dout)
   );
endmodule

module v1374eb (
 input vb35196,
 output vfe7756
);
 wire w0;
 wire w1;
 assign w0 = vb35196;
 assign vfe7756 = w1;
 v1374eb_ve3b07d ve3b07d (
  .s1(w0),
  .start(w1)
 );
endmodule

module v1374eb_ve3b07d (
 input s1,
 output start
);
 reg aux = 0;
 always @(posedge s1) begin
       aux <= 1;
 end
 assign start = aux;
endmodule

module v51874b (
 input [7:0] v1bc444,
 input v4f674c,
 input v568692,
 output vd78cf1
);
 wire w0;
 wire w1;
 wire w2;
 wire [0:7] w3;
 assign vd78cf1 = w0;
 assign w1 = v4f674c;
 assign w2 = v568692;
 assign w3 = v1bc444;
 v0cb733 v991e41 (
  .vd5c431(w0),
  .v641703(w1),
  .v9b2233(w2),
  .v82830a(w3)
 );
endmodule

module v0cb733 (
 input v641703,
 input [7:0] v82830a,
 input v9b2233,
 output vd5c431
);
 wire w0;
 wire w1;
 wire w2;
 wire [0:7] w3;
 assign vd5c431 = w0;
 assign w1 = v641703;
 assign w2 = v9b2233;
 assign w3 = v82830a;
 v0cb733_va9361c va9361c (
  .PWM_ESC(w0),
  .clock(w1),
  .start(w2),
  .velocity(w3)
 );
endmodule

module v0cb733_va9361c (
 input clock,
 input [7:0] velocity,
 input start,
 output PWM_ESC
);
 localparam pulses_nedded = 16380; 
 
 reg [13:0] pulses_nedded_velocity = 17'd0; //24009 maximo
 reg [13:0] count = 0; 
 reg T = 0;
 
 always @(posedge clock)
 begin
   count <= (count == pulses_nedded-1) ? 0: count+1;
   pulses_nedded_velocity <= ((velocity*14'd64) >=16380) ? 16379: (velocity*14'd64);
 
 end
 
 always @(posedge clock)
 begin
   if(start==1'b1)
     T <= (count <= pulses_nedded_velocity) ? 1:0;
 end
 assign PWM_ESC = T;
 
endmodule

module v3e6c24 (
 output v608bd9
);
 wire w0;
 assign v608bd9 = w0;
 v3e6c24_v68c173 v68c173 (
  .v(w0)
 );
endmodule

module v3e6c24_v68c173 (
 output v
);
 // Bit 1
 
 assign v = 1'b1;
endmodule

module vade377 (
 input v3f8fed,
 output v8ba3c1,
 output vc83139,
 output v11608b,
 output v1b05bb,
 output v19aebb,
 output vd73ec1
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 wire w6;
 assign v1b05bb = w0;
 assign vc83139 = w1;
 assign v11608b = w2;
 assign v19aebb = w3;
 assign v8ba3c1 = w4;
 assign vd73ec1 = w5;
 assign w6 = v3f8fed;
 vade377_v70e6a3 v70e6a3 (
  .EN(w0),
  .IN1(w1),
  .IN2(w2),
  .SF(w3),
  .INV(w4),
  .D1(w5),
  .sw2(w6)
 );
endmodule

module vade377_v70e6a3 (
 input sw2,
 output INV,
 output IN1,
 output IN2,
 output EN,
 output SF,
 output D1
);
 
 
 
 
 reg EN_reg = 1;//sleep mode 
 reg D1_reg = 0; //para configurar el triestado de la salida, para controlar si es el dutty el que maneja o tiempo en baja
 //D2_reg <= 1;//para configurar el trisestado de la salida
 reg IN1_reg = 1; //se estable un sentido para el mov
 reg IN2_reg = 0; //se estable un sentido para el mov, negado de in1 si queremos que se mueva
 reg INV_reg = 0; //si cambiamos inv la rueda cambia de sentido
 
 
 always@(posedge sw2)
 begin
 INV_reg = !INV_reg;
 end
 
 assign INV = INV_reg;
 assign IN1 = IN1_reg;
 assign IN2 = IN2_reg;
 assign EN = EN_reg;
 assign D1 = D1_reg;
 
endmodule

module main_v84997f (
 input [7:0] data,
 input ready,
 output [7:0] velocity
);
 
 reg state = 1'b0;
 reg [7:0] data1 = 8'd0;
 reg [7:0] data2 = 8'd0;
 
 always @(posedge ready)
 begin
     case(state)
     
     1'b0:
     begin 
         data1<= data;
         state<= 1'b1;
     end
     
     1'b1:
     begin
         data2<= data;
         state<= 1'b0;
     end
     endcase
 end
 assign velocity = data1;
 
endmodule

module main_vd108d8 #(
 parameter aux = 0
) (
 output [7:0] veloc
);
 assign veloc = aux;
endmodule
